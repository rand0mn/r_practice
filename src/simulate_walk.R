# Напушите симуляцию блуждания, чтобы блуждание начиналось в центре координат (0, 0),
# а все переходы по координатам x и y были бы независимы и имели стандартное 
# нормальное распределение. Если вас пугают эти слова, то это то же самое, что делал я,
# только отдельно по x и по y.
# 
# Процесс обрывается в момент выхода за границу круга с центром в (0, 0) и радиусом 6.
# Вероятность поглощения на каждом шаге равна 0.01. Максимальное количество шагов — 100.
# Расстояние, разумеется, евклидово.
# Один шаг процесса подразумевает изменение обеих координат одновременно!
# Теперь, когда все параметры зафиксированы, вероятность выхода частицы за пределы круга
# строго определена. Наша задача — найти эту вероятность. Это некоторое число, не зависящее
# от реализации алгоритма. Его можно даже вычислить теоретически, но это не так-то просто.
# Поэтому в подобных случаях пользуются моделированием: запускают алгоритм достаточно 
# большое количество раз (скажем, миллион траекторий) и оценивают долю частиц, вылетевших 
# за границу. Эта доля и есть приближение вероятности, которую мы ищем
# (реверанс в сторону закона больших чисел).
# 
# Для того, чтобы в нашей задаче определить нужную вероятность с точностью до целых процентов,
# достаточно будет ста тысяч запусков, у меня это несколько секунд. Если у вас считается
# слишком долго, то грубую оценку можно получить и для десяти тысяч запусков.
# 
# В ответе укажите вероятность вылета частицы в процентах, с точностью до целых процентов,
# в виде XX (например, 14, без указания значка процентов). Вероятность должна получиться больше 50%.


simulate_walk <- function(radius = 6, n_max = 100, p_absorb = 1e-2) {
  x <- 0
  y <- 0
  
  for (i in 1:n_max) {
    is_absorbed <- rbinom(1, 1, p_absorb)
    
    if (is_absorbed) return(list(status = 'Absorbed', x = x, y = y, steps = i))
    
    x <- x + rnorm(1)
    y <- y + rnorm(1)
    
    distance <- sqrt(x^2 + y^2)
    
    if (distance > radius) return(list(status = 'Breach', x = x, y = y, steps = i))
  }
  return(list(status = 'Max steps reached', x = x, y = y, steps = n_max))
}

n <- 1000000

res <- replicate(n, simulate_walk(), simplify = F)

df <- data.frame(
  status = sapply(res, function(x) x$status),
  x = sapply(res, function(x) x$x),
  y = sapply(res, function(x) x$y),
  steps = sapply(res, function(x) x$steps)
)

tapply(df$steps, df$status, length) / n

# Output
# Absorbed            Breach Max steps reached 
# 0.189361          0.809914          0.000725
